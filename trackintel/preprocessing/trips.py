from datetime import timedelta
import geopandas as gpd
import pandas as pd
import numpy as np
from tqdm import tqdm
from pyproj import Geod

import trackintel as ti


def generate_tours(
    trips_inp,
    stps_w_locs=None,
    max_dist=100,
    max_time=timedelta(days=1),
    max_nr_gaps=0,
    print_progress=False,
):
    """
    Generate trackintel-tours from trips
    - Tours are defined as a collection of trips in a certain time frame that start and end at the same point
    - Nested tours are possible and will be regarded as two distinct tours

    Parameters
    ----------
    trips_inp : GeoDataFrame (as trackintel trips)
        The trips have to follow the standard definition for trips DataFrames

    stps_w_locs : GeoDataFrame (as trackintel staypoints, preprocessed to contain location IDs), default None
        The staypoints have to follow the standard definition for staypoints DataFrames. The location ID column
        is necessary to connect trips via locations to a tour. If None, trips will be connected based only on a
        distance threshold `max_dist`.

    max_dist: float, default 100 (meters)
        Maximum distance between the end point of one trip and the start point of the next trip on a tour.
        Note: If `max_nr_gaps > 0` (see below), a tour can contain gaps

    max_time: Timedelta, default 1 day
        Maximum time that a tour is allowed to take

    max_nr_gaps: int, default 0
        It is possible to allow gaps to occur on the tour, which might be useful to deal with missing data.
        Example: home-work, supermarket-home would still be detected as a tour when max_nr_gaps >= 1, although
        the work-supermarket trip is missing.
        Warning: So far, neither temporal nor spatial distances of gaps are bounded (except by max_time)! Thus, this
        parameter should be set with caution, because trips that are hours apart might still be connected to a tour if
        `max_nr_gaps > 0`.

    print_progress : bool, default False
        If print_progress is True, the progress bar is displayed


    Returns
    -------
    trips: GeoDataFrame (as trackintel trips)
        Same as `trips_inp`, but with additional column `tour_id`

    tours: GeoDataFrame (as trackintel tours)
        The generated tours

    """
    # Two options: either the location IDs for staypoints on the trips are provided, or a maximum distance threshold
    # between end and start of trips is used
    if stps_w_locs is not None:
        assert (
            "location_id" in stps_w_locs.columns
        ), "Staypoints with location ID is required, otherwise tours are generated wo location from maximum distance"
        geom_col = "none" # not used
    else:
        # if no location is given, we need the trips table to have a geometry column
        assert isinstance(trips_inp, gpd.geodataframe.GeoDataFrame), "Trips table must be a GeoDataFrame"
        geom_col = trips_inp.geometry.name
    trips = trips_inp.copy()

    kwargs = {
        "max_dist": max_dist,
        "max_nr_gaps": max_nr_gaps,
        "max_time": max_time,
        "stps_w_locs": stps_w_locs,
        "geom_col": geom_col,
    }
    if print_progress:
        tqdm.pandas(desc="User trip generation")
        tours = (
            trips.groupby(["user_id"], group_keys=False, as_index=False)
            .progress_apply(_generate_tours_user, **kwargs)
            .reset_index(drop=True)
        )
    else:
        tours = (
            trips.groupby(["user_id"], group_keys=False, as_index=False)
            .apply(_generate_tours_user, **kwargs)
            .reset_index(drop=True)
        )

    # No tours found
    if len(tours) == 0:
        return trips, tours

    # index management
    tours["id"] = np.arange(len(tours))
    tours.set_index("id", inplace=True)

    # assign tour id to trips
    tour2trip_map = tours[["trips"]].to_dict()["trips"]
    ls = []
    for key, values in tour2trip_map.items():
        for value in values:
            ls.append([value, key])
    temp = pd.DataFrame(ls, columns=[trips.index.name, "tour_id"]).set_index(trips.index.name)
    trips = trips.join(temp, how="left")

    ## dtype consistency
    # trips id (generated by this function) should be int64
    tours.index = tours.index.astype("int64")
    trips["tour_id"] = trips["tour_id"].astype("Int64")

    # cleaning
    tours.drop(columns=["trips"], inplace=True)

    return trips, tours


def _generate_tours_user(
    user_trip_df, stps_w_locs=None, max_dist=100, max_nr_gaps=0, max_time=timedelta(days=1), geom_col="geom"
):
    user_id = user_trip_df["user_id"].unique()
    assert len(user_id) == 1
    user_id = user_id[0]

    # sort by time
    user_trip_df = user_trip_df.sort_values(by=["started_at"])

    # save only the trip id (row.name) in the start candidates
    start_candidates = []

    # collect tours
    tours = []
    # Iterate over trips
    for i, row in user_trip_df.iterrows():
        trip_id = row.name  # trip id
        end_time = row["finished_at"]
        # print("current candidates", start_candidates)

        # check if there is a gap between the previous and current trip
        if len(start_candidates) > 0:
            # compare end of last to start of new
            if stps_w_locs is not None:
                end_start_at_same_loc = _check_same_loc(
                    user_trip_df.loc[start_candidates[-1], "destination_staypoint_id"],  # dest. stp of previous trip
                    row["origin_staypoint_id"],  # start stp of current trip
                    stps_w_locs,
                )
            else:
                # check distance between point 1: end point of previous trip, point 2: start of current trip
                end_start_at_same_loc = _check_max_dist(
                    user_trip_df.loc[start_candidates[-1], geom_col][1], row[geom_col][0], max_dist
                )

            # if the current trip does not start at the end of the previous trip, there is a gap
            if not end_start_at_same_loc:
                # option 1: no gaps allowed - start search again
                if max_nr_gaps == 0:
                    start_candidates = [row.name]
                    continue
                # option 2: gaps allowed - search further
                else:
                    start_candidates.append(np.nan)

        # Add this point as a candidate
        start_candidates.append(row.name)

        # Check whether endpoint would be an unkown activity
        if pd.isna(row["destination_staypoint_id"]):
            continue

        # keep a list of which candidates to remove (because of time frame)
        new_list_start = 0

        # check distance to all candidates (except the ones that are too close)
        for j, cand in enumerate(start_candidates):
            # gap
            if np.isnan(cand):
                continue

            # check time difference - if time too long, we can remove the candidate
            cand_start_time = user_trip_df.loc[cand, "started_at"]
            if end_time - cand_start_time > max_time:
                new_list_start = j + 1
                continue

            # check whether the start-end candidate of a tour is an unkown activity
            if pd.isna(user_trip_df.loc[cand, "origin_staypoint_id"]):
                continue

            # TODO: compute length of triplegs and sum - must be larger than minthresh
            # check if endpoint of trip = start location of cand
            if stps_w_locs is not None:
                end_start_at_same_loc = _check_same_loc(
                    user_trip_df.loc[cand, "origin_staypoint_id"],  # start stp of first trip
                    row["destination_staypoint_id"],  # destination stp of current trip
                    stps_w_locs,
                )
            else:
                # check distance between point 1: end point of current trip, point 2: start of first trip on tour
                end_start_at_same_loc = _check_max_dist(row[geom_col][1], user_trip_df.loc[cand, geom_col][0], max_dist)

            # print("Check distance to start", cand, end_point, cand_start_point, point_dist)
            if end_start_at_same_loc:
                # Tour found!
                # collect the trips on the tour in a list
                non_gap_trip_idxs = [c for c in start_candidates[j:] if ~np.isnan(c)]
                tour_candidate = user_trip_df[user_trip_df.index.isin(non_gap_trip_idxs)]
                tours.append(_create_tour_from_stack(tour_candidate, stps_w_locs, max_dist, max_time, geom_col))

                nr_gaps = np.sum(np.isnan(np.array(start_candidates[j:])))

                if nr_gaps > max_nr_gaps:
                    # No tour found, too many gaps inbetween
                    continue
                # print("Tour found!", tour_candidate.head())

                # remove trips that were on the tour
                start_candidates = start_candidates[:j]
                # remove gap if there is a gap in the end
                if len(start_candidates) > 0 and np.isnan(start_candidates[-1]):
                    del start_candidates[-1]
                # do not consider the other trips - one trip cannot close two tours at a time anyway
                break

        # remove points because they are out of the time window
        start_candidates = start_candidates[new_list_start:]

    tours_df = pd.DataFrame(tours)
    return tours_df


def _check_same_loc(stp1, stp2, stps_w_locs):
    if pd.isna(stp1) or pd.isna(stp2):
        return False
    return stps_w_locs.loc[stp1, "location_id"] == stps_w_locs.loc[stp2, "location_id"]


def _check_max_dist(p1, p2, max_dist):
    """
    Check whether two points p1, p2 are less or equal than max_dist apart

    Parameters
    --------
    p1, p2: shapely Point objects
    max_dist: int

    Returns
    ------
    dist_below_thresh: bool
        indicating whether p1 and p2 are less than max_dist apart
    """
    geod = Geod(ellps="CPM")  # other guy used WGS84
    dist = geod.inv(p1.x, p1.y, p2.x, p2.y)[2]
    dist_below_thresh = dist <= max_dist
    return dist_below_thresh


def _create_tour_from_stack(temp_tour_stack, stps_w_locs, max_dist, max_time, geom_col):
    """
    Aggregate information of tour elements in a structured dictionary.

    Parameters
    ----------
    temp_tour_stack : list
        list of dictionary like elements (either pandas series or python dictionary).
        Contains all trips that will be aggregated into a tour

    Returns
    -------
    tour_dict_entry: dictionary

    """
    # this function return and empty dict if no tripleg is in the stack
    first_trip = temp_tour_stack.iloc[0]
    last_trip = temp_tour_stack.iloc[-1]

    # get location ID if available:
    if stps_w_locs is not None:
        start_loc = stps_w_locs.loc[first_trip["origin_staypoint_id"], "location_id"]
        # double check whether start and end location are the same
        end_loc = stps_w_locs.loc[last_trip["destination_staypoint_id"], "location_id"]
        assert start_loc == end_loc
    else:
        # double check distance between start and end point
        assert _check_max_dist(last_trip[geom_col][1], first_trip[geom_col][0], max_dist)
        # set location to NaN since not available
        start_loc = pd.NA

    # all data has to be from the same user
    assert len(temp_tour_stack["user_id"].unique()) == 1

    # double check if tour requirements are fulfilled
    assert last_trip["finished_at"] - first_trip["started_at"] <= max_time

    tour_dict_entry = {
        "user_id": first_trip["user_id"],
        "started_at": first_trip["started_at"],
        "finished_at": last_trip["finished_at"],
        "origin_staypoint_id": first_trip["origin_staypoint_id"],
        "destination_staypoint_id": last_trip["destination_staypoint_id"],
        "trips": list(temp_tour_stack.index),
        "location_id": start_loc,
    }

    return tour_dict_entry
